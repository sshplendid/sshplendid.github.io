---
layout: post
title:  "쿠버네티스 컨셉1"
date:   2019-09-09 19:03:00 +0900
categories: [blog, dev, kubernetes]
img: https://d33wubrfki0l68.cloudfront.net/1567471e7c58dc9b7d9c65dcd54e60cbf5870daa/da576/_common-resources/images/flower.png
tags: [kubernetes, 쿠버네티스, devops]
---

## 쿠버네티스는 무엇인가

쿠버네티스는 컨테이너화된 작업이나 서비스를 관리하기 위한 오픈소스 플랫폼이다. 쿠버네티스는 선언적인 구성과 자동화를 가능케 한다. 쿠버네티스(kubernetes)라는 이름은 배의 조타수(helmsman)로부터 유래되었다. 구글은 2014년에 쿠버네티스 프로젝트를 오픈소스로 공개했다.

## 쿠버네티스를 왜 써야하는가

우리는 쿠버네티스가 나온 배경부터 알아야 한다.

* 가상화 이전: 모든 애플리케이션은 물리서버 위에서 실행되었다. 애플리케이션 리소스의 바운더리를 정리할 방법이 없었고 이로 인해 리소스 할당 이슈가 야기되었다. 예를 들어 여러 애플리케이션이 한 서버 위에서 실행되고 있다면 한 서비스가 대부분의 서버 리소스를 사용해서 다른 서비스의 퍼포먼스가 낮아질 수 있다. 이 문제의 해결방법은 각 애플리케이션이 오로지 자신만을 위한 서버를 갖는 것이다. 이런 구조는 스케일링이 불가능하고 애플리케이션 인스턴스가 늘어날 때마다 물리 서버를 추가해야 하기 때문에 유지보수비용이 많이 들어간다.
* 가상화: 이 문제를 해결하기 위해서 가상화 개념이 도입됐다. 물리서버 위에 여러개의 가상머신이 실행되는데 가상머신 간의 리소스를 격리시키고 타 애플리케이션에 대한 접근이 어렵기 때문에 보안성이 향상되었다.  가상화는 리소스 사용의 효율화를 가져왔고 애플리케이션의 확장성이 좋기 때문에 하드웨어 유지보수비용이 크게 줄어들었다. 각 VM들은 OS를 포함한 모든 구성요소가 실행하는 환경이다.
* 컨테이너: 컨테이너는 VM과 유사하지만 OS를 공유하면서 자원은 격리되어있다. 그러므로 좀 더 가볍다. 컨테이너는 VM과 유사하게 각자의 파일시스템, CPU, 메모리, 프로세스 공간 등을 가진다. 

## 쿠버네티스가 할 수 있는 것들

컨테이너는 애플리케이션을 번들링하고 실행하기 쉽다. 운영 환경에서도 컨테이너를 관리해야 하는데 이 와중에 다운타임이 없어야 한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너가 시작되어야 할 것이다. 이를 시스템화해서 쉽게 사용할 수 있는 방법이 쿠버네티스이다. 쿠버네티스는 애플리케이션을 탄력적으로 배포할 수 있는 프레임워크를 제공한다. 스케일링 조건, failover, 배포 패턴같은 것들을 관리한다. 

쿠버네티스가 제공하는 기능들

* 서비스 디스커버리 & 로드 밸런싱: 쿠버네티스는 DNS 네임이나 IP 주소를 사용해서 컨테이너를 외부에 노출한다. 만약 특정 컨테이너에 트래픽이 몰리면 트래픽을 분산시켜 모든 컨테이너가 안정적인 상태를 유지하게 한다.
* 스토리지 오케이스트레이션: 선택적인 스토리지 시스템 마운팅이 가능하다. 로컬 스토리지, 클라우드 서비스 프로바이더 등을 선택할 수 있다.
* 롤아웃/롤백 자동화: 배포할 컨테이너의 상태를 프로퍼티 파일로 기술할 수 있다. 이는 실제 배포된 컨테이너들의 상태를 원하는 상태로 변경한다. 쿠버네티스는 새로운 버전의 배포기술서로 상태를 변경하면 자동으로 새로운 컨테이너를 생성하고, 기존의 컨테이너는 자동으로 제거한다.(롤아웃) 이를 통해 다운타임 없이 새로운 컨테이너로 상태를 변경할 수 있다.
* 빈 패킹 자동화: 각 컨테이너에 필요한 리소스를 조절할 수 있다. 컨테이너에 리소스 요청이 있을 때, 쿠버네티스는 컨테이너 리소스를 관리하기 위한 최선의 결정을 내린다.
* 자가회복: 쿠버네티스는 사용자가 정의한 컨테이너 헬스체크를 하고 응답이 없으면 컨테이너를 제거하고 재시작한다. 이런 일련의 과정을 사용자가 원하기 전까지 알리지 않는다.
* 시크릿 & 구성요소 관리: 쿠버네티스는 비밀번호, 인증 토큰, SSH 키 같은 민감한 정보를 저장하고 관리한다. 사용자는 이런 정보 때문에 컨테이너 이미지를 다시 빌드할 필요가 없다. 그리고 이런 정보를 config 파일과 같은 곳에 저장할 필요가 없다. 